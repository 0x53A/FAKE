using System;
using System.Collections.Generic;
using System.IO;
using Fake;
using Machine.Specifications;
using Microsoft.FSharp.Core;

namespace Test.FAKECore
{
    public class when_accessing_internals
    {
        It should_have_access_to_FAKE_internals =
            () => AssemblyInfoFile.getDependencies(new List<AssemblyInfoFile.Attribute>());
    }

    public class when_using_fsharp_task_with_default_config
    {
        It should_use_system_namespace_and_emit_a_version_module = () =>
        {
            string infoFile = Path.GetTempFileName();
            var attributes = new[]
            {
                AssemblyInfoFile.Attribute.Product("TestLib"),
                AssemblyInfoFile.Attribute.Version("1.0.0.0")
            };
            AssemblyInfoFile.CreateFSharpAssemblyInfo(infoFile, attributes);
            const string expected = "namespace System\r\nopen System.Reflection\r\n\r\n[<assembly: AssemblyProductAttribute(\"TestLib\")>]\r\n[<assembly: AssemblyVersionAttribute(\"1.0.0.0\")>]\r\ndo ()\r\n\r\nmodule internal AssemblyVersionInformation =\r\n    let [<Literal>] Version = \"1.0.0.0\"\r\n";

            File.ReadAllText(infoFile)
                .ShouldEqual(expected.Replace("\r\n", Environment.NewLine));
        };
    }

    public class when_using_fsharp_task_with_custom_config
    {
        It should_use_custom_namespace_and_not_emit_a_version_module = () =>
        {
            var customConfig = new AssemblyInfoFile.AssemblyInfoFileConfig(false, new FSharpOption<string>("Custom"));
            string infoFile = Path.GetTempFileName();
            var attributes = new[]
            {
                AssemblyInfoFile.Attribute.Product("TestLib"),
                AssemblyInfoFile.Attribute.Version("1.0.0.0")
            };
            AssemblyInfoFile.CreateFSharpAssemblyInfoWithConfig(infoFile, attributes, customConfig);
            const string expected = "namespace Custom\r\nopen System.Reflection\r\n\r\n[<assembly: AssemblyProductAttribute(\"TestLib\")>]\r\n[<assembly: AssemblyVersionAttribute(\"1.0.0.0\")>]\r\ndo ()\r\n\r\n";
            File.ReadAllText(infoFile)
                .ShouldEqual(expected.Replace("\r\n", Environment.NewLine));
        };
    }

    public class when_using_csharp_task_with_default_config
    {
        It should_use_system_namespace_and_emit_a_version_module = () =>
        {
            string infoFile = Path.GetTempFileName();
            var attributes = new[]
            {
                AssemblyInfoFile.Attribute.Product("TestLib"),
                AssemblyInfoFile.Attribute.Version("1.0.0.0")
            };
            AssemblyInfoFile.CreateCSharpAssemblyInfo(infoFile, attributes);
            const string expected = "// <auto-generated/>\r\nusing System.Reflection;\r\n\r\n[assembly: AssemblyProductAttribute(\"TestLib\")]\r\n[assembly: AssemblyVersionAttribute(\"1.0.0.0\")]\r\nnamespace System {\r\n    internal static class AssemblyVersionInformation {\r\n        internal const string Version = \"1.0.0.0\";\r\n    }\r\n}\r\n";

            File.ReadAllText(infoFile)
                .ShouldEqual(expected.Replace("\r\n", Environment.NewLine));
        };
    }


    public class when_using_cppcli_task_with_default_config
    {
        It should_emit_valid_syntax = () =>
        {
            string infoFile = Path.GetTempFileName();
            var attributes = new[]
            {
                AssemblyInfoFile.Attribute.Product("TestLib"),
                AssemblyInfoFile.Attribute.Version("1.0.0.0")
            };
            AssemblyInfoFile.CreateCppCliAssemblyInfo(infoFile, attributes);
            const string expected = "// <auto-generated/>\r\nusing namespace System::Reflection;\r\n\r\n[assembly:AssemblyProductAttribute(\"TestLib\")];\r\n[assembly:AssemblyVersionAttribute(\"1.0.0.0\")];\r\n";

            File.ReadAllText(infoFile)
                .ShouldEqual(expected.Replace("\r\n", Environment.NewLine));
        };
    }
}
